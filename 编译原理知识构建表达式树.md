#### 游戏中的数学表达式
1. 游戏中的角色攻击目标时会有伤害数值，而数值会随着各种属性的不同而不同
    1. 身上没有伤害加强（或降低）的buff，则是一般的攻击伤害数值
    2. 身上有伤害加强（或降低）的buff，伤害数值则有很大的不同
    为了计算这些伤害数值，通常策划会有一套计算公式，不同的情况下，参数不同，比如一种伤害公式如下：
    finalDamage = 10 * $rate * $damageBuff - 0.5 * $defense * $defenseBuff

2. 程序为了支持这些算式的计算，基本采用的方案都是用逆波兰式来计算，其基本算法：
    逆波兰式算法
    1. 从左至右扫描一中缀表达式。
    2. 若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈
    3. 若读取的是运算符
        1. 该运算符为左括号"("，则直接存入运算符堆栈。
        2. 该运算符为右括号")"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号为止，此时抛弃该左括号。
        3. 该运算符为非括号运算符：
            1. 若运算符堆栈栈顶的运算符为左括号，则直接存入运算符堆栈。
            2. 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。
            3. 若比运算符堆栈栈顶的运算符优先级低或相等，则输出栈顶运算符到操作数堆栈，直至运算符栈栈顶运算符低于（不包括等于）该运算符优先级,或为左括号，并将当前运算符压入运算符堆栈。
    4. 当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。

    最近学到一个新的思路，采用编译原理中的知识来构建算式表达式树 https://www.cnblogs.com/OceanEyes/p/implement_a_interpreter.html

#### 编译原理思路构建数学表达式树
1. 程序编译的前期基本流程
    1. 词法分析器：扫描文本字符，提取字符序列，将他们组织成具有词法含义的次数，输出词法单元；
    2. 语法分析器：根据词法单元，构建表达式，形成抽象语法树;
    3. 语法分析树：确定语法是否正确

2. 构建算式的BNF
    一个数学表达式有数字、运算符等组成，并且运算符是左结合和有优先性，可以创建两个非终结符号expression(表达式) 和 term(项) ，分别对应这两个优先级层次，并使用另一个非终结符号factor(因子)来生成表达式的基本单元。
    
    其中将因子(factor)理解成不能被任何运算符分开的表达式。『不能分开』的意思是说当在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的运算分量。当然，因子本身作为一个整体可以成为该运算符的一个运算分量。如果这个因子是由一个括号括起来的表达式，那么这个括号将起到保护其不被分开的作用。
    factor->digit|(expr)
    digit->0|1|2|3|4|5|6|7|8|9

    一个（不是因子）项（term）是一个可能被高优先级的运算符x和/分开，但不能被低优先级运算符分开的表达式。
    term->term x factor|term / factor|factor

    一个（不是因子也不是项）表达式可能被任何一个运算符分开。
    expr->expr+term|expr-term|term

    这样可以得到的BNF范式是：
    expr->expr+term|expr-term|term
    term->term x factor|term/factor|factor
    factor->digit|(expr)

    使用这个BNF范式时，一个表达式就是一个由+或-分割开来的项（term）列表，而项是由x或者/分隔的因子（factor）列表。请注意，任何由括号括起来的表达式都是一个因子。